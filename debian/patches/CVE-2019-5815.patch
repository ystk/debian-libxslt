From: Nick Wellnhofer <wellnhofer@aevum.de>
Date: Wed, 20 Feb 2019 13:24:37 +0100
Subject: [PATCH] Always set context node before calling XPath iterators
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 8bit

The xmlXPathNext* iterators rely on the XPath context node being set to
the start node of the iteration. Some parts of the code base like the
xsl:key functions also leave the context node in an unspecified state.
Make sure that the context node is reset before invoking the XPath
iterators. Also backup and restore the context node in
xsltNumberFormatGetMultipleLevel for good measure.

This bug could also lead to type confusion and invalid reads in
connection with namespace nodes.

Fixes #13. Also see the Chromium bug report:

https://bugs.chromium.org/p/chromium/issues/detail?id=930663

Thanks to Nicolas GrÃ©goire for the report.
---
 libxslt/numbers.c | 34 ++++++++++++++++++++++------------
 1 file changed, 22 insertions(+), 12 deletions(-)

diff --git a/libxslt/numbers.c b/libxslt/numbers.c
index 2a59fa4..a26249c 100644
--- a/libxslt/numbers.c
+++ b/libxslt/numbers.c
@@ -687,41 +687,51 @@ xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,
 {
     int amount = 0;
     int cnt;
+    xmlNodePtr oldCtxtNode;
     xmlNodePtr ancestor;
     xmlNodePtr preceding;
     xmlXPathParserContextPtr parser;
 
-    context->xpathCtxt->node = node;
+    oldCtxtNode = context->xpathCtxt->node;
     parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);
     if (parser) {
 	/* ancestor-or-self::*[count] */
-	for (ancestor = node;
-	     (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);
-	     ancestor = xmlXPathNextAncestor(parser, ancestor)) {
+	ancestor = node;
+	while ((ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE)) {
 
 	    if ((fromPat != NULL) &&
 		xsltTestCompMatchList(context, ancestor, fromPat))
 		break; /* for */
 
+	    /*
+	     * The xmlXPathNext* iterators require that the context node is
+	     * set to the start node. Calls to xsltTestCompMatch* may also
+	     * leave the context node in an undefined state, so make sure
+	     * that the context node is reset before each iterator invocation.
+	     */
+
 	    if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {
 		/* count(preceding-sibling::*) */
 		cnt = 1;
-		for (preceding =
-                        xmlXPathNextPrecedingSibling(parser, ancestor);
-		     preceding != NULL;
-		     preceding =
-		        xmlXPathNextPrecedingSibling(parser, preceding)) {
-
-	            if (xsltTestCompMatchCount(context, preceding, countPat,
-                                               node))
+		context->xpathCtxt->node = ancestor;
+		preceding = xmlXPathNextPrecedingSibling(parser, ancestor);
+		while (preceding != NULL) {
+		    if (xsltTestCompMatchCount(context, preceding, countPat,
+					       node))
 			cnt++;
+		    context->xpathCtxt->node = ancestor;
+		    preceding =
+			xmlXPathNextPrecedingSibling(parser, preceding);
 		}
 		array[amount++] = (double)cnt;
 		if (amount >= max)
 		    break; /* for */
 	    }
+	    context->xpathCtxt->node = node;
+	    ancestor = xmlXPathNextAncestor(parser, ancestor);
 	}
 	xmlXPathFreeParserContext(parser);
+	context->xpathCtxt->node = oldCtxtNode;
     }
     return amount;
 }
